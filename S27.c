// 2차원 배열과 배열 포인터
#include <stdio.h>
void EX1(void)
{
  int arr[2][3] = {
      {1, 2, 3},
      {4, 5, 6}};
  // arr[0]은 0번째 행 전체를 하나의 배열로 보자.

  /*
1. ptr == &ptr[0]
2. *ptr == ptr[0]
3. ptr + 1 == ptr + sizeof(*ptr)을 더한 값
*/
  int(*ptr)[3] = &arr[0]; // 크기가 3인 배열을 가리키는 포인터가 arr[0]의 주소를 가리킨다. 정확히 따지면, 값은 arr과 같지만, 3개짜리 배열을 가리키고 있는거다.
  int(*ptr)[3] = arr;     // 위랑 같은 표현

  for (int i = 0; i < 2; i++)
  {
    for (int j = 0; j < 3; j++)
    {
      printf("%d ", ptr[i][j]);
    }
    printf("\n");
  }
  /*
  내 예상 : ptr이라는 포인터는 arr 주소니까 아래처럼 나올꺼다.
  1 2 3
  4 5 6
  */
  /*
  1. ptr[i] == arr[i]
  2. ptr[i][j] == arr[i][j]
  3. ptr == arr
  세가지가 맞는지 증명해보자.
  *(ptr + i)는 ptr이 크기가 3인 배열을 가리키니 12i만큼 주솟값이 늘어난다. 즉 ptr + i 는 arr의 i번째 행을 가리킨다. 즉 arr[i]라는거다.
  이렇게 ptr == arr이 되버린다.
  어떤 느낌이나면
  int srr[3] = {1, 2, 3};에서
  int *psrr = srr;이렇게 썼으니
  int srr[2][3] = {{1 ,2, 3}, {4, 5, 6}};은
  int *psrr[3]이 구체적인 srr포인터 역할을 대치한다고 할 수 있다.
  결론 : 2차원 배열을 포인터로 가리키고 싶다면, 2차원 배열의 한 행을 가리키는 배열 포인터를 만들어서 arr를 대입하면 사용할 수 있다.

  */

  // 위를 이해했다면 아래 코드도 예상 가능하다.
  for (int(*row)[3] = arr; row < arr + 2; row++)
  {
    for (int *col = *row; col < *row + 3; col++)
    {
      printf("%d ", *col);
    }
    printf("\n");
  }
  /*
  해석하자면, row는 크기가 3인 배열을 가리키는 포인터(주소를 담고있음)이다. 그리고 col은 *row의 값을 담는데, row 값이 커질땐 row가 12바이트짜리를 가리키는 포인터니깐 다음행이 되고,
  col 1개짜리를 가리키는 포인터 즉 4바이트 하나 짜리, 커질때 1열씩 커진다. 그래서 배열 전부를 출력하게 된다.
  */
}

int main(void)
{
  EX1();
}